# -*- coding: utf-8 -*-
"""practice2_mlm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13u94C5Cu0hRWnJ0J8DT1TFG8kpIHltSI
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from keras.preprocessing import image
import os

print(train_df.columns)

print(X_train.dtypes)

print(y_train.dtypes)

print(X_train.head())

print(X_train.isnull().sum())

print(X_train.shape, y_train.shape)

X_train = train_df[['pixel size(mm)', 'head circumference (mm)']]

rf_model = RandomForestRegressor(n_estimators=100, random_state=42, max_features='sqrt')

from sklearn.ensemble import RandomForestRegressor
import pandas as pd

# Load the training and test data
train_df = pd.read_csv('/content/drive/MyDrive/Data/practice2/training_set_pixel_size_and_HC.csv')
test_df = pd.read_csv('/content/drive/MyDrive/Data/practice2/test_set_pixel_size.csv')

# Inspect the structure of the training DataFrame
print(train_df.head())  # Check the first few rows
print(train_df.columns)  # Check column names

# Preprocess the images (not needed for random forest)
# Define your features and target variable
X_train = train_df.drop(columns=['filename', 'head circumference (mm)'])  # Drop 'filename' column
y_train = train_df['pixel size(mm)']

# Check the contents of X_train to ensure features are present
print(X_train.head())

# Define the model (Random Forest Regressor)
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)  # You can adjust parameters as needed

# Train the model
rf_model.fit(X_train, y_train)

# Prepare test data
X_test = test_df.drop(columns=['filename'])

# Predict on the test set
rf_pred = rf_model.predict(X_test)

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error
import pandas as pd

# Load the training data
train_df = pd.read_csv('/content/drive/MyDrive/Data/practice2/training_set_pixel_size_and_HC.csv')

# Define features and target variable
X = train_df.drop(columns=['filename', 'head circumference (mm)'])  # Drop irrelevant columns
y = train_df['pixel size(mm)']

# Split the data into training and validation sets
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.25, random_state=42)

# Define the model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
rf_model.fit(X_train, y_train)

# Evaluate the model
train_preds = rf_model.predict(X_train)
val_preds = rf_model.predict(X_val)

train_mse = mean_squared_error(y_train, train_preds)
train_mae = mean_absolute_error(y_train, train_preds)
val_mse = mean_squared_error(y_val, val_preds)
val_mae = mean_absolute_error(y_val, val_preds)

print("Training MSE:", train_mse)
print("Training MAE:", train_mae)
print("Validation MSE:", val_mse)
print("Validation MAE:", val_mae)

# Load the test data
test_df = pd.read_csv('/content/drive/MyDrive/Data/practice2/test_set_pixel_size.csv')

# Prepare the test data
X_test = test_df.drop(columns=['filename'])

# Predict on the test set
test_preds = rf_model.predict(X_test)

# Optionally, save the predictions to a CSV file
test_df['pixel size(mm)_predicted'] = test_preds
test_df.to_csv('/content/drive/MyDrive/Data/practice2/test_set_pixel_size_with_predictions.csv', index=False)

from sklearn.metrics import mean_absolute_error

# Predict on the test set
pred = rf_model.predict(X_test)

# Get the true values
y_true = test_df['pixel size(mm)'].values

# Calculate MAE
mae = mean_absolute_error(y_true, pred)

print("Mean Absolute Error:", mae)

import matplotlib.pyplot as plt

# Visualize the results
plt.figure(figsize=(10, 6))
plt.scatter(pred, y_true, color='blue', label='Predicted vs. Actual')
plt.plot([min(pred), max(pred)], [min(pred), max(pred)], color='red', linestyle='--', label='Perfect Prediction')
plt.xlabel('Predicted Values')
plt.ylabel('Actual Values')
plt.title('Predicted vs. Actual Pixel Size (mm)')
plt.legend()
plt.show()

